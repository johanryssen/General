# rpmrebuild autogenerated specfile

BuildRoot: /home/vanceap/.tmp/rpmrebuild.9529/work/root
AutoProv: no
%undefine __find_provides
AutoReq: no
%undefine __find_requires
# Do not try autogenerate prereq/conflicts/obsoletes and check files
%undefine __check_files
%undefine __find_prereq
%undefine __find_conflicts
%undefine __find_obsoletes
# Be sure buildpolicy set to do nothing
%define __spec_install_post %{nil}
# Something that need for rpm-4.1
%define _missing_doc_files_terminate_build 0
#dummy
#dummy
#BUILDHOST:    localhost.localdomain
#BUILDTIME:    Mon Jun 26 16:45:55 2017
#SOURCERPM:    fixboot-5-1.src.rpm

#RPMVERSION:   4.4.2.3



#OS:           linux
#SIZE:           0
#ARCHIVESIZE:           124
#ARCH:         noarch
BuildArch:     noarch
Name:          fixboot
Version:       5
Release:       1
License:       None 
Group:         Development/System
Summary:       Moves /boot to a new disk



Vendor:        Interactive
Packager:      jpay@interactive.com.au





Provides:      fixboot = 5-1
Requires:      /bin/sh  
#Requires:      rpmlib(PayloadFilesHavePrefix) <= 4.0-1
#Requires:      rpmlib(CompressedFileNames) <= 3.0.4-1
#suggest
#enhance
%description
This package: will search for a new disk that is around 500MB.
If it finds a new disk, it will copy the existing /boot over
to the new disk and make appropriate changes to grub and fstab
%files
%pre -p /bin/sh
# ----------------------------------------------------------------------------
# test CONTINUE codes are as follows:
# 0 = move onto next step
# 99 = boot disk is already large enough
# the following CONTINUE codes are applicable if boot is not large enough
# 80 = No new disks available.
# 70 = Unused disks, but there is more than one that meet the criteria
# 40 = cant work with this version of grub. grub2 version of the script pending.
# 33 = cant work with EFI currently.
# 24 = umount mount of boot failed reboot required.
# 19 = failed to sfdisk
# 18 = failed to format
#
# TODO
# there are more, I'll have to update this section once I complete the code
# add more tests, and set the full path for all commands in the script in case the environment is empty.
# If the CONTINUE evaluates as 99, there is enough space in /boot already, just install the package.
# If CONTINUE ends up as a non-zero at the end, we cant fix /boot and dont install the package.
##

# reset all variables.
for variable in BOOTVOL BOOTTYPE BOOTSIZE CONTINUE CANDIDATES EMPTYDISK
do
export $variable=""
done
NOW="$(/bin/date +"%%y%%m%%d%%H%%M%%")"

# First Test. Simply check the current size of /boot if its bigger than 180MB, its fine.
read BOOTVOL BOOTTYPE BOOTSIZE <<< `/bin/df /boot -PT |/bin/awk -F" " '/\/boot$/{ print $1" "$2" "$3 }'`
if [ "$BOOTSIZE" -gt "180000" ]; then
CONTINUE=99
else
CONTINUE=0
fi

if [ $(/sbin/fdisk -l /dev/sd? |/bin/grep bytes$ |/bin/grep ^Disk |/usr/bin/wc -l) -gt 10 ]; then
CONTINUE=96
fi

# check what grub version is installed and if there are more than one.
if [ $CONTINUE -eq "0" ]; then
  # Check grub version. this script only works with legacy versions of grub at the moment.
  for DRIVE in $(/bin/ls /dev/sd[a-z] 2>/dev/null); do
   MBR_512="$(/usr/bin/hexdump -v -n 512 -e '/1 "%%02x"' ${DRIVE} 2>/dev/null)";
   MBR_sig2="${MBR_512:0:4}";
   MBR_sig3="${MBR_512:0:6}";
   MBR_sig4="${MBR_512:0:8}";
   MBR_sig8="${MBR_512:0:16}";
   if [ "$MBR_sig2" != "0000" ]; then
    GRUBCOUNT=$((GRUBCOUNT + 1))
    ## Bytes 0x80-0x81 of the MBR. ##
    #   Use it to differentiate between different versions of the same bootloader.
    MBR_bytes80to81="${MBR_512:256:4}";
    case ${MBR_sig2} in
      eb48) BL="GRUB_LEGACY" ;;
      eb4c) BL="GRUB2" ;;
      eb63) BL="GRUB2" ;;
         *) BL="UNKNOWN" ;;
    esac
   fi
  done
  if [ "$BL" != "GRUB_LEGACY" ] || [ "$GRUBCOUNT" -ne "1" ]; then
    CONTINUE=92
  fi
fi

# If CONTINUE=0, /boot is not large enough and we need to find a new disk.
# Lets probe for new disks if CONTINUE=0...
if [ $CONTINUE -eq "0" ]; then
 ls /sys/class/scsi_host/ 2>/dev/null | while read host
 do
  echo "- - -" > /sys/class/scsi_host/$host/scan
 done
 # now we sleep for 2 minutes because linux takes its time to find new disks...
 sleep 120
fi

# Now lets check if any disks are unused and if they are appropriate to use for the new /boot
if [ $CONTINUE -eq "0" ]; then
 # collect a list of candidates .. disks without any partition tables.
 CANDIDATES=$(/sbin/parted -l |/bin/awk -F"/" '/unrecognised disk label/ && /\/dev\/sd/{print substr($3,0,3)}')
 if [ -n '$CANDIDATES' ]; then
  for EMPTYDISK in $CANDIDATES
  do
   CANDIDATESIZE=`/sbin/sfdisk -s /dev/$EMPTYDISK`
   if [ "$CANDIDATESIZE" -gt 400000 ] && [ "$CANDIDATESIZE" -lt 600000 ]; then
    CANDIDATE="$CANDIDATE $EMPTYDISK"
   fi
  done
  # check if there are more than 1 candidate disks
  if [[ `echo $(c() { echo $#; }; c $CANDIDATE)` -eq 1 ]]; then
   CONTINUE=0
  else
   CANDIDATE=""
   CONTINUE=70
  fi
 else
  CONTINUE=80
 fi
fi

# at this point, we should have found a valid candidate disk or ruled it out.
# the candidate variable may contain a space at the front, lets strip it.
CANDIDATE=$(echo $CANDIDATE |/bin/sed 's/ //g')

if [ $CONTINUE -eq "0" ]; then
 if [ ! -f /sbin/grub ]; then
  CONTINUE=40
 fi
 if [ -d /sys/firmware/efi ]; then
  CONTINUE=33
 fi
fi


# lets confirm that we can umount and mount /boot
# if we can umount /boot and mount it again, we dont need a reboot to apply the fix.
if  [ $CONTINUE -eq "0" ]; then
 /bin/umount /boot >/dev/null 2>&1
 if [ $? -ne "0" ]; then
  # failed to unmount /boot.
  CONTINUE=24
 else
 /bin/mount /boot >/dev/null 2>&1
 fi
fi


# now to do the actual fix. this will do a quite a bit of work, its critical that
# all the test above have completed successfully.
if [ $CONTINUE -eq "0" ]; then
 # lets backup the critical files.
 /bin/cp -p /etc/fstab /etc/fstab.fixboot.$NOW
 /bin/cp -p /boot/grub/grub.conf /boot/grub/grub.conf.fixboot.$NOW
 /bin/mv /boot/grub/device.map /boot/grub/device.map.fixboot.$NOW

 # lets create a new partition on the candidate disk
 echo ';' | /sbin/sfdisk /dev/$CANDIDATE >/dev/null 2>&1
 if [ $? -ne "0" ]; then
  CONTINUE=19
 fi
 # if the partition was created successfully, we can make the filesystem.
 if [ $CONTINUE -eq "0" ];then
 # now lets create a partition as ext3 on the new partition
 # and test the exit code
  /sbin/mkfs.ext3 /dev/$CANDIDATE"1" >/dev/null 2>&1
  if [ $? -ne "0" ]; then
   CONTINUE=18
  fi

 fi
 # lets do some work with grub.
 if [ $CONTINUE -eq "0" ];then
  sleep 5 #take a breath
  # we need to regenerate the device.map file so we know which hdd the candidate
  # has been detected as by grub. we will get the UUID while we are at it.
  echo quit |/sbin/grub --device-map=/boot/grub/device.map >/dev/null 2>&1
  HDD=$(/bin/grep $CANDIDATE /boot/grub/device.map |/bin/awk -F"[(|)]" '{print $2}')
  UUID=$(/sbin/blkid -s UUID /dev/$CANDIDATE"1" |/bin/awk -F\" '{print $2}')
  OLDHDD=$(/bin/grep "$(echo "$BOOTVOL" |/bin/sed 's/.$//')" /boot/grub/device.map |/bin/awk -F"[(|)]" '{print $2}')
  if [ $HDD ]|[ $UUID ]|[ $OLDHDD ]; then
   CONTINUE=0
  else
   CONTINUE=18
  fi

  if [ $CONTINUE -eq "0" ];then
   # lets mount up the new partition and copy the current boot contents to the new boot
   if [ ! -d /$NOW ]; then
    /bin/mkdir /$NOW
    /bin/mount -t ext3 /dev/$CANDIDATE"1" /$NOW
    if [ $? -ne "0" ]; then
     # the mount of the new filesystem failed. sadface.
     CONTINUE=17
    fi
   fi
  fi

  # point of no return, after this, there its a mannual backout as boot is changed.
  # this line updates /etc/fstab with replacing the existing device with the new one.
  if [ $CONTINUE -eq "0" ];then
   /bin/cat /etc/fstab.fixboot.$NOW |/bin/sed 's/.*\/boot/UUID='$UUID'\t\/boot/g' > /etc/fstab
   /bin/cp -p /boot/grub/grub.conf /boot/grub/grub.conf.orig
   > /boot/grub/grub.conf
   # this code takes the existing /boot/grub/grub.conf and copies the first menu.
   # updates it, and adds it as the first entry. This is another critical step.
   # Read in the whole grub.conf
   GRUBORIG=$(</boot/grub/grub.conf.orig)
   # get just the top of the grub.conf, up to the first menu
   GRUBHEAD=$(echo "$GRUBORIG" |/bin/sed -n '/^title/!p;//q')
   # replace the original hd with the target hd for the splash
   NEWGRUBHEAD=$(echo "$GRUBHEAD" |/bin/sed 's/'$OLDHDD'/'$HDD'/g')
   # get the rest
   # lets copy all the rest and replace the hdds
   NEWREST=$(echo "$GRUBORIG" |/bin/sed -n '/^title/,$p' )
   GRUBFIRST=$(echo "$NEWREST" |/bin/sed 's/'$OLDHDD'/'$HDD'/g' |/bin/sed 's/title /title NEW/g' )
   echo "$NEWGRUBHEAD" >/boot/grub/grub.conf
   echo "$GRUBFIRST" >>/boot/grub/grub.conf
   echo "$NEWREST" >>/boot/grub/grub.conf
   # copy everything from /boot to the new /boot
   /bin/cp -paR /boot/. /$NOW/.
   /bin/umount /$NOW
   /bin/rmdir /$NOW
   # we have already tested umounting /boot so lets update it now
   /bin/umount $BOOTVOL >/dev/null 2>&1
   /bin/mount /boot
# This command updates the grub bootloader.
/sbin/grub --batch <<EOF >/dev/null 2>&1
root ($HDD,0)
setup ($OLDHDD)
quit
EOF
   # We should be able to update kernels without a reboot, and when rebooting,
   # end up on the new boot with the menu as a backout.
  fi
 fi
fi

if [ $CONTINUE -eq "0" ] || [ $CONTINUE -eq "99" ]; then
 exit 0
else
 exit 1
fi
%changelog
* Mon Jun 26 2017 Jason Pay <jpay@interactivecom.au> - 5.1
- Updated date field
- fixed final test to produce exit codes for rpm

* Tue Jun 20 2017 Jason Pay <jpay@interactivecom.au> - 5.0
- Updated the grub.conf modify procedure
- Added a 2 minute sleep to allow time for new disks to be scanned.
- Added test to check if number of disk is above 10 limitation.

