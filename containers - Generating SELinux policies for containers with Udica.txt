Generating SELinux policies for containers with Udica

--- Step 1 Software installation and configuration ---

Install the udica and setools-console packages on the container host
# yum install -y udica setools-console

Get the latest RHEL8 UBI image
# podman pull registry.access.redhat.com/ubi8/ubi:latest

Use podman to list the available container images
# podman images

Terminal_2: Create a container runtime using podman which:
- Passes in-container accesses to /home through to the host's /home read-only
- Passes in-container accesses to /var/spool through to the host's /var/spool read-write
- Binds the host's port 80 to pass traffic to the container's port 80.
# CONTAINER=$(podman run -v /home:/home:ro -v /var/spool:/var/spool:rw -d -p 80:80 -it registry.access.redhat.com/ubi8/ubi)

NOTE:
/home mounted READ-ONLY
/var/spool/ mounted READ-WRITE

Terminal_1: Check the status of the application container using podman and get the running container id
# podman ps; CONTAINERID=$(podman ps | grep registry.access.redhat.com | cut -b 1-12)
	CONTAINER ID  IMAGE                         COMMAND               CREATED        STATUS           PORTS               NAMES
	123123123  registry.access.redhat.com/ubi8/ubi:latest  /bin/bash  3 seconds ago  Up 2 seconds ago0.0.0.0:80->80/tcp  some_thing

When using SELinux, container processes get assigned a container type called 'container_t'.
Verify the SELinux type assigned to the running container
# ps -eZ | grep container_t
	system_u:system_r:container_t:s0:c182,c1016 43210 pts/0 00:00:00 bash

On RHEL, SELinux is enabled by default and in enforcing mode.
To confirm:
# sestatus


--- Step 2 Inspecting container access and SELinux policies ---

Terminal_2: Use podman exec to create an interactive shell inside the running container.
# podman exec -t -i $CONTAINER /bin/bash

Check container's access to /home directory
# cd /home; ls
	ls: cannot open directory '.': Permission denied

Terminal_1: Query the SELinux policy to search for ALLOW ENFORCEMENT RULES applied to access /home directory
# sesearch -A -s container_t -t home_root_t -c dir -p read
The search returns NO results.

Since, there is no allow rule for container_t type to get read access to the /home directory, access is blocked by SELinux.

Terminal_1: Check container's access to /var/spool/ directory
# cd /var/spool/; ls
	ls: cannot open directory '.': Permission denied

SELinux is restricting access to the /var/spool directory.
Terminal_2: Check the container's write access to the /var/spool/ directory
# touch test
	touch: cannot touch 'test': Permission denied

Terminal_1: Query the SELinux policy to search for ALLOW ENFORCEMENT RULES applied to access /var/spool directory
# sesearch -A -s container_t -t var_spool_t -c dir -p read
The search returns NO results.

Since, there is no allow rule for container_t type to get read access to the /var/spool/ directory, access is blocked by SELinux.

Query the SELinux policy for network access for container_t types
# sesearch -A -s container_t -t port_type -c tcp_socket
	allow container_net_domain port_type:tcp_socket { name_bind name_connect recv_msg send_msg };
	allow corenet_unconfined_type port_type:tcp_socket { name_bind name_connect recv_msg send_msg };
	allow sandbox_net_domain port_type:tcp_socket { name_bind name_connect recv_msg send_msg };

'sandbox' is the default process type (domain) in SELinux.
'container' is the domain used in the context of containers.
'corenet' type is typically used in the context of the Linux kernel.
The output means that for each of these domains, binding, connecting, sending and receiving messages are allowed without TCP port restrictions.


--- Step 3 Generating SELinux container policies with Udica ---

To create the custom SELinux security policy, Udica scans the container JSON file to discover which Linux capabilities are required by the container.
The network ports are a similar situation where Udica uses the SELinux userspace libraries to get the correct SELinux label of a port that is used by the inspected container.

Terminal_1: Inspect the running container using podman to generate a container inspection file in JSON format
# podman inspect $CONTAINERID > container.json

Tell Udica to generate the custom SELinux security policy by using the container JSON file.
In this case the name of the custom SELinux security policy is called 'new_container'
# udica -j container.json new_container
	Policy new_container created!
	Please load these modules using:
	\# semodule -i new_container.cil /usr/share/udica/templates/{base_container.cil,net_container.cil,home_container.cil}
	Restart the container with: "--security-opt label=type:new_container.process" parameter

You just created a custom SELinux security policy for the container.

Now you can load this policy into the kernel and make it active.
# semodule -i new_container.cil /usr/share/udica/templates/{base_container.cil,net_container.cil,home_container.cil}

For the policies to take effect, stop and re-launch the container
# podman stop $CONTAINERID

Terminal_2: Create a new container runtime from the image which uses the new, custom container policy
# CONTAINER=$(podman run --security-opt label=type:new_container.process -v /home:/home:ro -v/var/spool:/var/spool:rw -d -p 80:80 -it registry.access.redhat.com/ubi8/ubi)


--- Step 4 Verifying the SELinux container policies with Udica ---

Verify the policies generated using Udica for the container and enforced by SELinux.
Query the SELinux policy on the container host to search for ALLOW ENFORCEMENT RULES applied to access /home directory:
# sesearch -A -s new_container.process -t home_root_t -c dir -p read
	allow new_container.process home_root_t:dir { getattr ioctl lock open read search };

There is an allow rule in place that allows read access to the /home directory.

Query the SELinux policy on the container host to search for ALLOW ENFORCEMENT RULES applied to access /var/spool/ directory.
# sesearch -A -s new_container.process -t var_spool_t -c dir -p read
	allow new_container.process var_spool_t:dir { add_name getattr ioctl lock open read remove_name searchwrite };

There is an allow rule in place that allows read access to the var/spool directory.

Query the SELinux policy on the container host to check network access
# sesearch -A -s new_container.process -t port_type -c tcp_socket
	allow new_container.process http_port_t:tcp_socket { name_bind name_connect recv_msg send_msg };

Retrieve the SELinux type associated with TCP port 80. TCP port 80 is the port that Apache will bind on.
# semanage port -l | grep -w "80"



--- Step 5 Re-inspect the running container ---

Terminal_2: exec into the running container and start a bash shell
# podman exec -t -i $CONTAINER /bin/bash

# Check whether container has access to the /home directory
cd /home/; ls
	packer  rhel

This is now successful since there is an allow rule in place that tells SELinux to allow this action.

Check whether container has read access to the /var/spool/ directory
# cd /var/spool/; ls
	anacron  cron  lpd  mail  plymouth  rhsm

Also successful because there is an allow rule in place that tells SELinux to allow this action.

Check whether container has write access to the /var/spool/ directory
# touch test; ls
	anacron  cron  lpd  mail  plymouth  rhsm  test

Install the netcat (nc) package inside the container to test for port bindings
# yum install -y nc

Tell nc to listen on port 80 inside the container, and timeout after 5 seconds.
# timeout 5s nc -lvvp 80
	Ncat: Listening on :::80
	Ncat: Listening on 0.0.0.0:80

Netcat was able to connect and listen on port 80.
This is successful because there is a allow rule in place that tells SELinux to allow this network action on port 80.

Tell nc to listen on port 8080 inside the container, and timeout after 5 seconds.
# timeout 5s nc -lvvp 8080
	Ncat: bind to :::8080: Permission denied. QUITTING.

Netcat was NOT able to connect and listen on port 8080.
There is no allow rule in place that tells SELinux to allow this operation, and hence it was blocked by SELinux.

-----